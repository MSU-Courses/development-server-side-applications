# Работа с базой данных в Express.js

## Зачем использовать базу данных в бэкенд-приложениях?

При разработке серверных приложений возникает необходимость где-то сохранять данные – так, чтобы они не терялись между запусками сервера и были доступны множеству пользователей. Если хранить информацию только в оперативной памяти (например, в переменных Node.js), данные пропадут при перезапуске приложения или сбое сервера [^1]. Кроме того, память сервера ограничена и дорога, особенно если данных много (сотни мегабайт или гигабайты). База данных решает эту проблему, обеспечивая _персистентность данных_ – постоянное хранение на диске, благодаря которому информация переживает рестарты приложения и отключения питания.

Например, представьте веб-сайт с регистрацией пользователей. Пока сервер запущен, можно держать список пользователей в массиве. Но что случится, если сервер упадет или перезагрузится? Без базы данных все зарегистрированные пользователи придется вводить заново – явно неприемлемо. _База данных_ (Database) позволяет сохранить данные пользователей на жестком диске в структурированном виде, чтобы при следующем запуске приложения они были доступны. Более того, базы _данных оптимизированы для эффективного поиска, сортировки и фильтрации больших объемов информации_, чего сложно достичь с простыми файловыми записями.

Другой плюс – несколько экземпляров приложения (например, на разных серверах) могут обращаться к одной базе данных и тем самым разделять общие данные. Без БД приходилось бы придумывать собственный механизм синхронизации или обмена информацией между серверами. База данных выступает централизованным хранилищем, к которому могут подключаться разные части системы.

Наконец, современные СУБД (системы управления базами данных) обеспечивают дополнительные преимущества: они защищают данные от одновременного доступа (средствами транзакций и блокировок), сохраняют только изменения (журналы транзакций) для надежности, могут автоматически восстанавливать данные после сбоев. Вручную реализовать все эти функции крайне сложно. Именно поэтому в большинстве веб-приложений базу данных называют сердцем приложения – без нее не обойтись [^2].

> Базы данных бывают разных видов. В этом курсе мы используем реляционную базу данных PostgreSQL, где данные хранятся в таблицах и к ним обращаются с помощью языка SQL. Существуют и NoSQL-базы (например, MongoDB, Redis и др.), но их мы пока не рассматриваем. Важно понимать, что принципы сохранения данных и взаимодействия с приложением у них схожие – разница в структуре хранения и способах запросов.

## Установка и настройка PostgreSQL

Для начала работы нам нужно установить сервер базы данных PostgreSQL на свою машину (или запустить его в контейнере). Разберем два подхода: ручная установка напрямую в систему и запуск PostgreSQL через Docker-контейнер.

### Ручная установка PostgreSQL (1). Установка на компьютер

PostgreSQL является кроссплатформенной СУБД. В зависимости от вашей ОС существуют разные способы установки.

#### Linux

_Для Linux (Ubuntu/Debian)_ доступен пакет `postgresql`. Для установки выполните команды:

```bash
sudo apt update && sudo apt install postgresql postgresql-contrib
```

Это установит сервер и утилиты (включая консольный клиент `psql`, с помощью которого можно взаимодействовать с БД через терминал).

#### macOS

_Для macOS_ часто используют приложение Postgres.app. Скачайте его с [официального сайта](https://postgresapp.com/) и следуйте инструкциям по установке. После установки запустите приложение, чтобы запустить сервер PostgreSQL.

#### Windows

_Для Windows_ можно использовать установщик с [официального сайта PostgreSQL](https://www.postgresql.org/download/windows/). Скачайте и запустите установочный файл, следуя инструкциям мастера установки.

### Ручная установка PostgreSQL (2). Настройка базы данных

Настройка базы данных будет показана на примере графического интерфейса _pgAdmin_, который на Windows устанавливается вместе с PostgreSQL.

#### Создание пользователя

1. Запустите _pgAdmin_.  
   <img src="https://img001.prntscr.com/file/img001/kY3FXzX7S-K_58mwqVihKw.png" alt="pgAdmin" width="600">

2. При первом запуске программа запросит пароль для доступа к интерфейсу. Введите его и нажмите _OK_.

3. В левой части окна находится дерево объектов. Разверните пункт `Servers`.  
   <img src="https://img001.prntscr.com/file/img001/JJajDSN4QBCbHLErJtWKoA.png" alt="pgAdmin" width="600">

4. Щёлкните правой кнопкой мыши на _Login/Group Roles_ и выберите `Create` → `Login/Group Role...`.  
   <img src="https://img001.prntscr.com/file/img001/IiSAXPn8TN6Q9N80Qqz_Ag.png" alt="pgAdmin" width="600">

5. Во вкладке _General_ введите имя нового пользователя (например, `blog_usr`).  
   <img src="https://img001.prntscr.com/file/img001/kTU84F8ETiGVPE8iDl06Qg.png" alt="pgAdmin" width="600">

6. Перейдите на вкладку _Definition_ (#1) и установите пароль для пользователя (#2).  
   <img src="https://img001.prntscr.com/file/img001/o0t0_oOnRiaPlmN86emlLA.png" alt="pgAdmin" width="600">

7. Затем откройте вкладку _Privileges_ (#1) и установите флажок _Can Login_ (#2).  
   <img src="https://img001.prntscr.com/file/img001/wTutZRHASDmCH5TxUih63A.png" alt="pgAdmin" width="600">

8. Нажмите кнопку _Save_ в правом нижнем углу, чтобы создать пользователя.

#### Создание базы данных

1. В дереве объектов щёлкните правой кнопкой мыши на _Databases_ и выберите `Create` → `Database...`.  
   <img src="https://img001.prntscr.com/file/img001/6Sgdeg7_QkGoPsjbhY4QIQ.png" alt="pgAdmin" width="600">

2. Во вкладке _General_ укажите имя базы данных (например, `blog`) (#1) и выберите ранее созданного пользователя в поле _Owner_ (#2).
   <img src="https://img001.prntscr.com/file/img001/7S5224wKS-imknvqIUflwA.png" alt="pgAdmin" width="600">

3. Нажмите кнопку _Save_ в правом нижнем углу.

4. Новая база данных появится в списке слева (#1), а внутри неё вы сможете создавать таблицы и другие объекты (#2).  
   <img src="https://img001.prntscr.com/file/img001/1-LuNcXNQRG7opPpKgQmAA.png" alt="pgAdmin" width="600">

#### Данные для подключения к базе данных

Для подключения к созданной базе данных в своём приложении используйте следующие параметры:

| Параметр       | Значение                                           |
| -------------- | -------------------------------------------------- |
| _Хост_         | `localhost`                                        |
| _Порт_         | `5432` (порт по умолчанию для PostgreSQL)          |
| _База данных_  | Имя базы (например, `blog`)                        |
| _Пользователь_ | Имя созданного пользователя (например, `blog_usr`) |
| _Пароль_       | Пароль, заданный при создании пользователя         |
| _Кодировка_    | `UTF-8`                                            |
| _Драйвер_      | `pgsql` (используется в PDO или других клиентах)   |

### Установка PostgreSQL в Docker-контейнере

_Альтернативный подход_ – не устанавливать СУБД напрямую, а воспользоваться Docker. Контейнер Docker с PostgreSQL позволяет быстро получить работающую базу, изолированно от основной системы. Для установки необходимо:

1. _Установка Docker_. Сначала убедитесь, что Docker Engine установлен и запущен на вашей машине. Инструкции по установке Docker доступны на [официальном сайте](https://docs.docker.com/get-docker/).
2. _Запуск контейнера с Postgres_. Docker Hub предоставляет официальный образ postgres. Достаточно выполнить команду:
   ```bash
   docker run --name my-postgres -e POSTGRES_PASSWORD=mypassword -d -p 5432:5432 postgres
   ```
3. _Подключение к базе_. После запуска контейнера база будет доступна на `localhost:5432` с пользователем `postgres` и паролем `mypassword`. Вы можете использовать pgAdmin или любой другой клиент для управления базой.
4. _Сохранение данных_. Чтобы данные сохранялись между перезапусками контейнера, рекомендуется использовать Docker Volume:
   ```bash
   docker volume create pgdata
   docker run --name my-postgres -e POSTGRES_PASSWORD=mypassword -d -p 5432:5432 -v pgdata:/var/lib/postgresql/data postgres
   ```
5. _Вход в контейнер_. Для выполнения команд внутри контейнера используйте:

   ```bash
   docker exec -it my-postgres bash
   ```

   Затем можно запустить `psql` для работы с базой:

   ```bash
   psql -U postgres
   ```

   Подключится к базе данных можно и через терминал хоста:

   ```bash
   psql -h localhost -U postgres
   ```

## Использование PostgreSQL в Express.js приложении

Настроив базу данных, можно подключить её к бэкенд-приложению на Express.js.

### Установка и подключение к базе данных из Node.js (библиотека pg)

Node.js не умеет общаться с СУБД напрямую – нужен драйвер или клиентская библиотека. Для PostgreSQL в экосистеме Node наиболее популярна библиотека `pg` (она же node-postgres) [^3]. Она предоставляет функционал для установления соединения с базой и выполнения SQL-запросов из JavaScript.

Для _установка библиотеки_, в проекте Node (где уже инициализирован package.json) выполните команду:

```bash
npm install pg
```

Для подключения к базе данных можно использовать два способа:

- _Client_. Это отдельное соединение к базе, которое вы сами открываете и закрываете. Подходит для редких одиночных запросов.
- _Pool_. Это пул соединений: по сути менеджер, держащий несколько открытых подключений и переиспользующий их для разных запросов. При частых запросах (например, в веб-сервере) постоянно открывать/закрывать соединение накладно, поэтому пул удерживает набор подключений. Когда приходит новый запрос к базе, пул либо использует свободное уже открытое соединение, либо создаст новое (в пределах заданного лимита). Для веб-приложения на Express пул подходит идеально.

Пример подключения к базе с помощью пула:

```javascript
// db/pool.js
import { Pool } from 'pg';

// Создаем пул подключений
const pool = new Pool({
  host: 'localhost', // адрес сервера БД (для локальной БД – localhost)
  port: 5432, // порт, на котором слушает Postgres (5432 по умолчанию)
  database: 'myuser', // имя базы данных
  user: 'myuser', // имя пользователя (роли) PostgreSQL
  password: 'mypassword', // пароль пользователя БД
});

export default pool;
```

Ключи `host`, `port`, `database`, `user`, `password` – это параметры соединения. Здесь они прописаны явно для наглядности. Однако, _хранить пароль в коде небезопасно_. В реальных проектах эти значения читают из _переменных окружения_ (`.env`). Например, можно заранее задать следующие переменные:

- `DB_USER` - имя пользователя
- `DB_PASSWORD` - пароль
- `DB_HOST` - адрес сервера базы данных
- `DB_PORT` - порт
- `DB_NAME` - имя базы данных

А затем их использовать в коде через `process.env`:

```javascript
const pool = new Pool({
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  database: process.env.DB_NAME,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
});
```

### Выполнение SQL-запросов из Express.js

Для взаимодействия с базой данных в Express.js есть несколько способов. Самый простой – использовать метод `pool.query()` из библиотеки `pg`.

Библиотека `pg` предоставляет метод `pool.query()` для выполнения SQL-запроса.

_Синтаксис_:

```javascript
pool.query(text[, values], callback)
```

- `text`. Строка с SQL-запросом (например, "SELECT \* FROM users").
- `values`. (необязательно) Массив значений для параметризованных запросов (например, [1, 'John']).
- `callback`. (необязательно) Функция обратного вызова, которая вызывается после выполнения запроса.

_Пример 1_. SELECT-запрос

Предположим в базе данных есть таблица `users` с колонками `id`, `name`, `email`. Чтобы получить всех пользователей, необходимо выполнить SELECT-запрос:

```javascript
import pool from './db/pool.js';

async function getAllUsers() {
  try {
    const res = await pool.query('SELECT * FROM users');
    return res.rows; // массив объектов с данными пользователей
  } catch (err) {
    console.error('Ошибка при получении пользователей:', err);
  }
}
```

Метод `pool.query` вернет объект результата, в котором наиболее полезное – поле `rows` (массив строк результата). В данном случае rows будет массивом пользователей. Нашу функцию `getAllUsers()` можно вызывать из других частей кода, она вернет данные из БД.

_Пример 2_. INSERT-запрос

Используем базу данных пользователей, из прошлого примера. Создадим функцию для добавления нового пользователя:

```javascript
import pool from './db/pool.js';

async function addUser(name, email) {
  try {
    await pool.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);
  } catch (err) {
    console.error('Ошибка при добавлении пользователя:', err);
  }
}
```

Обратите внимание, мы написали запрос с использованием `$1` и `$2`. Это место плейсхолдера для параметра. Значения для подстановки мы передаем вторым аргументом query в массиве `[name, email]`. Она крайне важна для безопасности: если просто подставлять строку в SQL через конкатенацию `("... VALUES ('" + name + "')")`, злоумышленник мог бы передать в переменной name фрагмент SQL-кода и изменить логику запроса (SQL injection).

После выполнения INSERT-запроса в БД новый пользователь появится в таблице `users`.

Нужно учитывать, что разные типы SQL-запросов возвращают разные результаты:

- _SELECT_ возвращает набор строк (массив объектов) в `res.rows`.
- _INSERT, UPDATE_, _DELETE_ возвращают объект с информацией о выполнении (например, сколько строк затронуто) в `res.rowCount`.
- _DDL-запросы_ (CREATE TABLE, DROP TABLE и т.д.) обычно не возвращают полезных данных, но могут выбросить ошибку при неудаче.

## Модель в MVC

После того как вы освоили основы работы с базой данных в Express.js, важно рассмотреть вопрос правильной организации кода и определить, где именно следует размещать SQL-запросы. Поскольку вы уже знакомы с архитектурным паттерном MVC (Model–View–Controller), напомним, что его ключевая идея заключается в разделении ответственности между слоями приложения. Согласно этому принципу, бизнес-логика и операции доступа к данным должны быть изолированы от контроллеров и представлений. За управление данными отвечает слой _Model (моделей)_.

### Модель

_Model (Модель)_ – компонент, отвечающий за бизнес-логику приложения и управление данными. Проще говоря, модель содержит логику доступа к данным и их обработки. В классическом MVC модель может взаимодействовать с базой данных, выполнять вычисления, применять правила предметной области. Модель ничего не знает про HTTP или интерфейс – ею пользуются контроллеры, чтобы получить или изменить данные.

В нашем приложении роль модели выполняют функции, такие как `getAllUsers()` и `addUser()`. Эти функции инкапсулируют логику взаимодействия с базой данных — формирование и выполнение SQL-запросов — и предоставляют контроллерам простой и понятный интерфейс для работы с данными, например: «вернуть список пользователей» или «добавить нового пользователя».

_Пример 3_. Функции модели для работы с пользователями

```javascript
// models/user.js

import pool from '../db/pool.js';

export async function getAllUsers() {
  const res = await pool.query('SELECT * FROM users');
  return res.rows;
}

export async function getUserById(id) {
  const res = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
  return res.rows[0]; // возвращаем первый (и единственный) результат
}

export async function addUser(name, email) {
  await pool.query('INSERT INTO users (name, email) VALUES ($1, $2)', [name, email]);
}

export async function getUserById(id) {
  const res = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
  return res.rows[0]; // возвращаем первый (и единственный) результат
}

export async function updateUser(id, name, email) {
  await pool.query('UPDATE users SET name = $1, email = $2 WHERE id = $3', [name, email, id]);
}
```

Контроллеры в этом случае будут вызывать функции модели для получения или изменения данных, не заботясь о деталях SQL-запросов:

_Пример 4_. Контроллеры, использующие функции модели

```javascript
// controllers/userController.js

import { getAllUsers, getUserById, addUser, updateUser } from '../models/user.js';

export async function listUsers(req, res) {
  const users = await getAllUsers();
  return res.json(users);
}

export async function getUser(req, res) {
  const user = await getUserById(req.params.id);
  if (user) {
    return res.json(user);
  } else {
    return res.status(404).send('User not found');
  }
}

export async function createUser(req, res) {
  const { name, email } = req.body;
  await addUser(name, email);
  return res.status(201).send('User created');
}

export async function editUser(req, res) {
  const { name, email } = req.body;
  await updateUser(req.params.id, name, email);
  return res.send('User updated');
}

// и т.д.
```

## Хорошие практики организации кода

Для поддержания чистоты и удобочитаемости кода при работе с базой данных рекомендуется придерживаться следующих практик:

- Держите параметры подключения (логин/пароль и др.) вне кода – в настройках или переменных окружения.
- Разделяйте конфигурацию подключения и сами запросы. Например, один модуль инициализирует Pool (как db/pool.js), а другой содержит функции запросов (`models/`).
- Не выполняйте SQL напрямую в обработчиках маршрутов. Вместо этого вызывайте функции модели.
- Обрабатывайте ошибки при работе с БД (например, в примере выше мы обернули вызовы в `try...catch`).
- Используйте параметризированные запросы всегда, когда вставляете внешние данные в SQL, чтобы защититься от SQL-инъекций.

## Использование MySQL/MariaDB: альтернатива PostgreSQL

Хотя в этом курсе мы используем PostgreSQL, многие принципы работы с базой данных в Express.js остаются теми же при использовании других СУБД, таких как MySQL или MariaDB. Основные отличия будут в установке драйвера и синтаксисе SQL-запросов.

Для работы с MySQL в Node.js популярна библиотека `mysql2`. Установка и подключение к базе данных будут выглядеть следующим образом:

```bash
npm install mysql2
```

```javascript
import mysql from 'mysql2/promise';
const pool = mysql.createPool({
  host: 'localhost',
  user: 'myuser',
  password: 'mypassword',
  database: 'mydatabase',
  waitForConnections: true,
  queueLimit: 0,
});

export default pool;
```

SQL-запросы в MySQL схожи с PostgreSQL, но могут иметь некоторые отличия в синтаксисе. Например, для вставки данных используется `?` вместо `$1`, `$2`:

```javascript
await pool.query('INSERT INTO users (name, email) VALUES (?, ?)', [name, email]);
```

## Миграции базы данных

В процессе разработки приложения структура базы данных (таблицы, поля, типы данных, связи и ограничения) часто изменяется: добавляются новые таблицы, поля, индексы, меняются типы и правила. Миграции позволяют управлять такими изменениями последовательно и контролируемо.

Миграция — это файл (SQL или скрипт), описывающий, как перевести базу данных из одного состояния в другое.

### Зачем нужны миграции?

- _Версионирование базы_. Миграции позволяют вести учёт всех изменений в структуре БД, так же как система контроля версий отслеживает изменения в коде. Это даёт возможность понять, кто и когда внёс изменения в схему.
- _Командная разработка_. Каждый разработчик может применять миграции и получать актуальную версию базы без ручного вмешательства. Это исключает ситуации, когда структура БД на локальной машине отличается от общей.
- _Деплой на разные окружения_. При переносе приложения на другие среды (dev, staging, production) миграции позволяют легко и безопасно обновить базу данных, применив все нужные изменения в правильной последовательности.
- _Откат изменений_. Некоторые системы миграций поддерживают откат (rollback) — возможность отменить последнее изменение, если оно оказалось ошибочным.

### Как реализуются миграции?

В самом простом виде миграция — это SQL-файл. Например:

```sql
-- файл: 20250401_create_users_table.sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

По имени файла видно, что таблица users создана 1 апреля 2025 года. Принято использовать префикс с датой или номером, чтобы определить порядок применения миграций.

### Инструменты для миграций

Существует множество библиотек и инструментов для управления миграциями в Node.js. Вот несколько популярных:

- _migrate_ [^4] - мигратор баз данных (CLI-утилита), написанный на Go, поддерживает работу с различными СУБД. Позволяет:

  - генерировать файлы миграций на чистом SQL;
  - применять (migrate) и откатывать (rollback) изменения;
  - отслеживать состояние миграций.

  Несмотря, что это не PHP-решение, его можно использовать в проектах на Node.js, вызывая

- _Knex.js_ - SQL query builder с поддержкой миграций. Позволяет писать миграции на JavaScript, используя API Knex для создания таблиц и полей.

### Пример миграции с go-migrate

1. Установите `migrate` (если ещё не установлен):

   ```bash
   brew install golang-migrate
   ```

2. Создайте папку для миграций в проекте:

   ```bash
   mkdir migrations
   ```

3. Сгенерируйте файл миграции:

   ```bash
   migrate create -ext sql -dir migrations create_users_table

   ```

4. В папке `migrations` появятся два файла:

- `20250401_create_users_table.up.sql` - для применения миграции
- `20250401_create_users_table.down.sql` - для отката миграции

5.  В файле `20250401_create_users_table.up.sql` напишите SQL для создания таблицы:

    ```sql
    CREATE TABLE users (
       id SERIAL PRIMARY KEY,
       name VARCHAR(100) NOT NULL,
       email VARCHAR(100) NOT NULL UNIQUE,
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    ```

6.  В файле `20250401_create_users_table.down.sql` напишите SQL для удаления таблицы:

    ```sql
    DROP TABLE users;
    ```

7.  Чтобы применить миграцию, выполните команду:

    ```bash
      migrate -path ./migrations -database "postgres://myuser:mypassword@localhost:5432/mydatabase?sslmode=disable" up
    ```

8.  Чтобы не выполнять команду вручную каждый раз, можно:

    1.  Добавить скрипт в `package.json`:

        ```json
        "scripts": {
          "migrate": "migrate -path ./migrations -database \"postgres://myuser:mypassword@localhost:5432/mydatabase?sslmode=disable\" up"
        }
        ```

    2.  Создать скрипт `migrate.js`:

        ```javascript
        // migrations/migrate.js
        import { exec } from 'child_process';

        exec(
          'migrate -path ./migrations -database "postgres://myuser:mypassword@localhost:5432/mydatabase?sslmode=disable" up',
          (error, stdout, stderr) => {
            if (error) {
              console.error(`Ошибка при миграции: ${error.message}`);
              return;
            }
            if (stderr) {
              console.error(`stderr: ${stderr}`);
              return;
            }
            console.log(`stdout: ${stdout}`);
          },
        );
        ```

[^1]: _Why do we use Databases when we could directly use them as variables in server program_. freecodecamp.org [online]. Available at: https://forum.freecodecamp.org/t/why-do-we-use-databases-when-we-could-directly-use-them-as-variables-in-server-program/480724/1
[^2]: _Installing PostgreSQL_. theodinproject.com [online]. Available at: https://www.theodinproject.com/lessons/nodejs-installing-postgresql
[^3]: _Using PostgreSQL_. theodinproject.com [online]. Available at: https://www.theodinproject.com/lessons/nodejs-using-postgresql
[^4]: _migrate_. github.com [online]. Available at:https://github.com/golang-migrate/migrate
