# Введение в Backend-разработку

## Что такое Backend и чем занимается Backend-разработчик?

_Бэкенд_ - это часть приложения, которая скрыта “за кулисами” пользовательского интерфейса. В контексте веб-приложений бэкенд называют _серверной_ стороной: он обрабатывает запросы, выполняет бизнес-логику, работает с данными и отвечает клиенту (фронтенду). Проще говоря, всё, что происходит на сайте невидимо для пользователя - хранение и обработка данных, вычисления, проверка доступа, взаимодействие с базой данных - относится к бэкенду. Например, когда вы ищете товар в интернет-магазине или заполняете веб-форму, именно бэкенд-часть приложения ищет нужные данные, выполняет расчёты (цены, налоги, доставка) и подготавливает информацию, прежде чем отправить её на фронтенд для отображения пользователю [^1].

Фронтенд (клиентская часть) - это то, что видит и с чем взаимодействует пользователь (кнопки, меню, страницы), а бэкенд (серверная часть) - это то, что происходит на сервере, обрабатывая запросы и управляя данными.

_Бэкенд-разработчик_ занимается созданием и поддержкой этой серверной части приложения. Его задачи могут включать:

- разработку и отладку основной логики программы,
- настройку и взаимодействие с базами данных,
- интеграцию приложения с внешними сервисами,
- создание API для связи с фронтендом,
- обеспечение безопасности и стабильной работы сервера.

Обычно говорят, что бэкенд состоит из трёх основных компонентов: сервера (физического или облачного хоста, где работает приложение), собственно приложения (серверного программного кода) и базы данных (хранилища информации) - все они постоянно работают в фоновом режиме, даже если пользователь напрямую их не видит. Ниже перечислены некоторые ключевые обязанности бэкенд-разработчика:

- _Работа с данными и базами данных_. Проектирование структуры хранения данных, сохранение и получение информации (например, сведения о пользователях, товарах, сообщениях) из базы данных.
- _Реализация логики приложения_. Написание серверного кода, который обрабатывает бизнес-правила (например, проверка корректности данных, расчёт результатов, выполнение необходимых вычислений).
- _Создание и поддержка API_. Разработка API (Application Programming Interface), через которые фронтенд и другие сервисы могут запрашивать данные или вызывать функции приложения (об этом подробнее ниже).
- _Интеграция сторонних сервисов_. Подключение внешних сервисов или микросервисов (например, сервисов оплаты, карт, уведомлений) и обмен данными с ними.
- _Обеспечение безопасности и стабильности_. Защита данных от несанкционированного доступа (например, настройка авторизации, шифрование), предотвращение взломов и утечек, резервное копирование данных и восстановление в случае сбоев.

Важно понимать разницу между фронтенд- и бэкенд-разработкой. Если фронтенд-разработчик отвечает за визуальную часть и взаимодействие с пользователем, то бэкенд-разработчик отвечает за “мозг” приложения - то есть за то, чтобы при запросе с клиента были получены нужные данные, они были правильно обработаны и возвращены обратно. Эти две стороны работают как команда: клиент (frontend) делает запрос (например, на получение списка товаров), сервер (backend) выполняет необходимую работу - ищет информацию, обращается к базе данных, применяет логику - и отправляет результат, после чего клиентская часть отображает данные пользователю. Таким образом, от работы бэкенда во многом зависит корректность и скорость функциональности приложения, хотя сам бэкенд остаётся “за кадром” пользовательского опыта.

## Клиент-серверная архитектура веб-приложений

Перед тем как углубляться в детали бэкенд-разработки, необходимо вспомнить основы клиент-серверной архитектуры, на которой базируются современные веб-приложения. С этим понятием вы уже сталкивались в курсе по веб-разработке, поэтому сейчас мы лишь освежим ключевые моменты.

_Клиент-серверная архитектура_ - это модель взаимодействия между двумя основными компонентами: клиентом и сервером. В контексте веб-приложений:

- _Клиент_ - это обычно веб-браузер или мобильное приложение, которое пользователь использует для доступа к веб-сайту или сервису. Клиент отправляет запросы на сервер и отображает полученные ответы (например, HTML-страницы, изображения, данные). Разработку клиентской части (фронтенда) обычно выполняют фронтенд-разработчики.
- _Сервер_ - это мощный компьютер или группа компьютеров, которые обрабатывают запросы от клиентов, выполняют необходимую работу (например, поиск данных, выполнение логики) и отправляют обратно ответы. Сервер может быть физическим устройством или виртуальным (облачным). Разработку серверной части (бэкенда) выполняют бэкенд-разработчики. 

Когда пользователь вводит URL в браузере или кликает по ссылке, клиент (браузер) отправляет HTTP-запрос на сервер. Сервер принимает этот запрос, обрабатывает его (например, ищет нужную страницу или данные в базе), и возвращает HTTP-ответ, который клиент отображает пользователю. Этот процесс может включать несколько шагов, таких как аутентификация пользователя, взаимодействие с базой данных, выполнение бизнес-логики и т.д.

## Архитектуры веб-приложений

*Архитектура веб-приложения* - это структура, которая определяет логическую и физическую организацию компонентов, их взаимодействие и методы связи для реализации веб-приложения.

Представьте, что вам необходимо построить дом. Прежде чем начать строительство, вы должны разработать план дома, определить количество комнат, их расположение, материалы и т.д. Точно так же и с веб-приложением. Прежде чем начать разработку, необходимо определить структуру приложения, его компоненты и взаимосвязь между ними.

Перед тем как создавать веб-приложение вам необходимо определить следующие вопросы:

- Какие компоненты будут входить в приложение?
- Какие компоненты будут взаимодействовать между собой?
- Какие технологии будут использоваться для реализации приложения?
- Какие принципы и паттерны проектирования будут использоваться? 

### Монолитная архитектура

*Монолитная архитектура* - это тип архитектуры, в котором все компоненты приложения находятся в одном месте [^7]. Фронтенд и бэкенд фактически не разделены - например, сервер (PHP) генерирует HTML-страницы на лету и отсылает их как ответ.  Это самый простой тип архитектуры, который хорошо подходит для небольших проектов.

До этого вы, вероятно, имели дело с монолитной архитектурой, так как это самый простой и понятный тип архитектуры. В таком подходе используется единая кодовая база, один язык программирования, одна база данных и т.д. Это привычный вам формат веб-приложений, который вы разрабатывали ранее.

### Headless архитектура. Разделение фронтенда и бэкенда

В современной веб-разработке всё чаще применяется подход с разделением _фронтенда_ и _бэкенда_. В этом случае они создаются как отдельные приложения, которые могут быть написаны на разных языках программирования и использовать разные технологии. Например, фронтенд может быть реализован на JavaScript с использованием React или Angular, а бэкенд - на PHP, Java или Node.js. При таком разделении фронтенд отвечает исключительно за отображение интерфейса и взаимодействие с пользователем, а бэкенд - за обработку данных и выполнение бизнес-логики.

Так как фронтенд и бэкенд существуют как отдельные приложения, они не могут взаимодействовать напрямую, как это происходило в монолитной архитектуре. Для обмена данными между ними используется _API_ (Application Programming Interface) - набор правил и протоколов, позволяющий разным программам взаимодействовать друг с другом. 

Такая архитектура получила название _headless_ (“без головы”, то есть без собственного интерфейса). Headless-бэкенд предоставляет только данные и функции через API, не занимаясь напрямую отображением информации. Фронтенд при этом существует как отдельное приложение (например, одностраничное приложение на JavaScript или мобильное приложение), которое запрашивает данные у бэкенда и самостоятельно отображает их пользователю. Бэкенд в headless-архитектуре фокусируется исключительно на обработке логики и данных и не зависит от способов их представления [^3]. Фронтенд, в свою очередь, сосредоточен на интерфейсе и опыте пользователя, не заботясь о том, как получить или обработать данные - для этого он обращается к бэкенду по API.

Благодаря такому разделению обязанностей изменить пользовательский интерфейс можно без переработки серверной логики, и наоборот. Кроме того, один и тот же бэкенд можно использовать сразу для нескольких клиентов: например, веб-сайта, мобильного приложения, умных устройств и т.д. - все они будут получать данные из единого источника через стандартные запросы. Допустим вы изменили бэкенд-логику (например, добавили новый способ расчёта скидок) - все клиенты (и веб, и мобильный) сразу начнут использовать обновлённую логику без необходимости вносить изменения в каждый из них.

![Рисунок 1. Взаимодействие клиентов и сервера в headless-архитектуре](../_images/01/01_01_client_server.png)

### Сервисно-ориентированная архитектура (SOA)

В случае описанном выше, весь бэкенд и фронтенд реализован как одно приложение, и он имеет множество недостатков: сложность масштабирования, отсутствие гибкости и адаптивности, сложность внесения изменений и тестирования, увeвеличение времени развертывания по мере роста приложения, высокий риск отказа всего приложения при ошибке в одном из компонентов.

Одним из решений данной проблемы стала _сервисно-ориентированная архитектура_. _Сервисно-ориентированная архитектура (Service Oriented Architecture, SOA)_ - это тип архитектуры, в котором приложение разбивается на независимые приложения, называемые *сервисами*, каждый из которых выполняет определенную функцию.

Проще говоря, у вас работают несколько независимых сервисов, которые взаимодействуют друг с другом через API. Каждый сервис выполняет свою функцию и может быть развернут на отдельном сервере.

![Рисунок 2. Сервисная архитектура](../_images/01/01_02_soa_architecture.png)

Как можно видеть на рисунке, в сервисной архитектуре бэкенд разбит на несколько независимых сервисов, у каждого может быть своя база данных и логика, и даже отдельный фронтенд.

| Преимущества                                                             | Недостатки                                                                      |
| ------------------------------------------------------------------------ | ------------------------------------------------------------------------------- |
| Гибкость и адаптивность                                                  | Сложность развертывания и управления множеством сервисов                        |
| Легкость масштабирования отдельных компонентов                           | Сложность мониторинга и отладки                                                 |
| Независимость разработки и развертывания                                 | Увеличение сложности инфраструктуры                                             |
| Повышенная устойчивость и отказоустойчивость                             | Потенциальные проблемы с производительностью из-за межсервисного взаимодействия |
| Возможность использования разных технологий и языков для разных сервисов | Усложнение координации между командами разработки                               |

Но с ростом количества пользователей, запросов и объема данных, сервисно-ориентированная архитектура также стала иметь свои недостатки. Поэтому разработчики стали искать новые подходы к разработке веб-приложений. Как итог, был разработан новый подход - _микросервисная архитектура_.

### Микросервисная архитектура

_Микросервисная архитектура_ - это тип архитектуры, в котором приложение разбивается на маленькие независимые сервисы, каждый из которых выполняет определенную функцию.

Многие могут подумать, что микросервисная архитектура это то же самое, что и сервисно-ориентированная архитектура, но это не так. Основное отличие заключается в размере сервисов. В микросервисной архитектуре сервисы должны быть максимально маленькими и независимыми.

В микросервисной архитектуре каждый микросервис обычно проектируется для выполнения одной конкретной задачи или функции, что обеспечивает его независимость и простоту масштабирования. В то время как традиционные сервисы могут объединять в себе несколько функций и не обязательно следовать принципу разделения обязанностей, присущему микросервисам.

Например, в SOA (сервис-ориентированной архитектуре) сервис "Управление пользователями" может включать функции регистрации, аутентификации и управления профилем в одном сервисе. В микросервисной архитектуре отдельный микросервис будет отвечать только за аутентификацию пользователей, а другие микросервисы займутся регистрацией и управлением профилем.

Как и другие типы архитектуры, микросервисная архитектура имеет свои преимущества и недостатки.

| Преимущества                                        | Недостатки                                                    |
| --------------------------------------------------- | ------------------------------------------------------------- |
| Гибкость и адаптивность                             | Сложность развертывания и управления множеством микросервисов |
| Независимое развертывание                           | Сложность мониторинга и отладки                               |
| Независимое масштабирование                         | Задержка сети при межсервисном взаимодействии                 |
| Маленькие целевые команды                           | Требования к более сложной инфраструктуре                     |
| Использование разных технологий для каждого сервиса | Повышенные требования к мониторингу и логированию             |
| Улучшенная поддержка и обновление                   | Потенциальное дублирование данных                             |
| Упрощенное управление кодовой базой                 | Более высокие затраты на разработку и поддержку               |

## Взаимодействие фронтенда и бэкенда через API (REST)

Когда фронтенд и бэкенд разделены, и тем более, когда бэкенд реализован как набор микросервисов, возникает вопрос: как же они будут взаимодействовать друг с другом? Связующим звеном служит API (Application Programming Interface) - программный интерфейс приложения. По сути, API - это набор правил и методов, позволяющих одним программам обращаться к функциональности других. В веб-разработке под API обычно понимают внешний интерфейс сервера, который описывает, какие запросы можно к нему сделать и какие данные будут возвращены. Благодаря API два разных приложения могут “разговаривать” друг с другом, даже если они написаны на разных языках или работают на разных платформах.

На практике для такого взаимодействия чаще всего используется _REST API_ - архитектурный стиль, основанный на протоколе HTTP. REST - это архитектурный стиль разработки распределённых систем, в том числе веб-сервисов. В контексте веба REST обычно использует протокол HTTP и задаёт ряд правил: использование стандартных HTTP-методов, понятные URL-адреса для ресурсов, передачу данных в определённых форматах, и очень важный принцип - статус без сохранения состояния (stateless).

Стоит упомянуть, что REST - не единственный подход к построению веб-API. Существуют и другие технологии, например, _GraphQL_ (графовый запросный язык от Facebook, позволяющий клиенту самому определять структуру нужных данных) или старый протокол _SOAP_ (основанный на XML и наборе стандартов для обмена сообщениями). Однако REST за счёт своей простоты и опоры на существующие веб-стандарты HTTP стал наиболее популярным, и большинство “headless”-приложений используют именно RESTful API.

Например, у вас есть два приложения: фронтенд на React и бэкенд на JavaScript. Они могут взаимодействовать следующим образом:

- Фронтенд отправляет запрос: "Бэкенд, мне нужны данные о пользователях".
- Бэкенд обрабатывает запрос и отвечает: "Хорошо, вот список пользователей в формате JSON".

Всё это взаимодействие происходит через сеть с использованием HTTP-запросов и ответов.

## Использование Node.js для бэкенд-разработки

Бэкенд-разработка не привязана к какому-то одному языку программирования или технологии. Существует множество языков и фреймворков, с помощью которых можно реализовать серверную часть веб-приложения. Выбор технологий часто зависит от задач проекта, производительности, существующей экосистемы и навыков команды. На стороне сервера могут работать как традиционные языки вроде Java, C#, Python, PHP, Ruby, так и JavaScript (благодаря платформе Node.js). Исторически для крупных веб-приложений и корпоративных систем широко применялись Java (с фреймворком Spring), C#/.NET, Python (Django, Flask) и PHP (Laravel, Symfony) - эти решения обеспечивают стабильность, богатые возможности и проверены временем. Однако в последние годы особую популярность приобрёл Node.js, который позволяет использовать JavaScript на сервере. Рассмотрим его в контексте нашего курса, как альтернативу Java.

Важно отметить, что выбор между Node.js и Java (или другими языками) зависит от конкретной задачи. Java славится надёжностью, богатой экосистемой для enterprise-разработки и строгой структурой кода. Крупные банки, финансовые системы, где критичны безопасность и многолетняя поддержка, традиционно выбирают Java. Node.js, со своей стороны, часто выбирается для быстрых веб-сервисов, микросервисов, реальных времени (например, систем чата, уведомлений) и когда нужна быстрая разработка. Он хорошо масштабируется горизонтально (запуск множества экземпляров на разных ядрах или серверах), поддерживает множество готовых модулей через npm и позволяет тому же человеку разрабатывать и клиентскую, и серверную часть приложения. Компании-гиганты успешно внедряют Node.js: например, переход некоторых сервисов PayPal и Netflix на Node.js позволил им сократить время отклика и время запуска приложений в разы [^4].

Node.js - не “замена” Java один к одному, а альтернативный подход к созданию бэкенда. В рамках курса мы будем изучать бэкенд с упором на Node.js (и, фреймворк Express.js для создания веб-сервера на Node). Это даст вам навык создания современного REST API на JavaScript, который очень востребован, особенно в сочетании с фронтенд-фреймворками вроде React или Angular. Но имейте в виду, что помимо Node.js, в бэкенде существуют и другие мощные технологии.

[^1]: _Frontend vs Backend Development_. geeksforgeeks.org. [online]. Available at: https://www.geeksforgeeks.org/blogs/frontend-vs-backend/
[^2]: _What Does a Backend Developer Do? The Complete Beginner’s Guide_. careerfoundry.com. [online]. Available at: https://careerfoundry.com/en/blog/web-development/backend-developer-guide/
[^3]: _Headless Architecture Explained to a 5-Year-Old_. medusajs.com [online]. Available at: https://medusajs.com/blog/headless-architecture/
[^4]: _Node.js vs Java: Choosing the right backend tech stack for your project_. peerbits.com [online]. Available at: https://www.peerbits.com/blog/nodejs-vs-java-backend-development-comparison.html
[^5]: _What is SOA (Service-Oriented Architecture)?_. aws.amazon.com [online]. Available at: https://aws.amazon.com/what-is/service-oriented-architecture/
[^6]: _Microservices_. aws.amazon.com [online]. Available at: https://aws.amazon.com/microservices/
[^7]: _Monolithic Architecture: What, Why and When_. medium.com [online]. Available at: https://medium.com/swlh/monolithic-architecture-what-why-and-when-986dc5d5ce03