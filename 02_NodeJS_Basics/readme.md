# Введение в Node.js. Node.js в качестве backend разработки

## Что такое Node.js и для чего он нужен?

*Node.js* – это среда выполнения JavaScript, которая позволяет запускать JavaScript-код вне браузера. Изначально JavaScript применялся только на стороне клиента (в браузере), однако появление Node.js в 2009 году (автор – Райан Даль) открыло возможность использовать JavaScript и на стороне сервера. Проще говоря, Node.js дает нам возможность выполнять JavaScript-код на компьютере, а не только в браузере [^1], что позволяет создавать серверные приложения, веб-серверы, инструменты командной строки и многое другое.

Node.js является *кроссплатформенной* и *открытой* технологией – она работает в операционных системах Windows, Linux, macOS и других. В основе Node.js лежит движок Chrome V8, написанный на C++: этот движок отвечает за выполнение JavaScript-кода, компилируя его в машинный код на лету (just-in-time компиляция). Благодаря V8 Node.js выполняет JavaScript быстро и эффективно. Но Node – это не только движок: он также включает ряд встроенных модулей (например, для работы с файловой системой, сетевыми запросами, потоками данных и т.д.) и реализует особую архитектуру работы с запросами, о чем речь пойдет далее.

*Node.js не является языком программирования* или *фреймворком*. Это именно среда (runtime), внутри которой ваш JavaScript-код выполняется на сервере. Когда мы запускаем JavaScript-файл с помощью Node.js, мы фактически загружаем его в среду, где доступны дополнительные возможности, недоступные в браузере. 


> Помимо Node.js, существуют и другие среды выполнения JavaScript, такие как Bun и Deno. Они предлагают современные решения и повышенную безопасность, однако Node.js остается наиболее популярной благодаря огромному сообществу и развитой экосистеме библиотек.

## Установка Node.js

Для начала работы с Node.js нужно установить его на свой компьютер. Обычно достаточно скачать установочный пакет с официального сайта Node.js и пройти простую установку.

1. Перейдите на официальный сайт: https://nodejs.org/en/download/.
2. Выберите установщик для вашей операционной системы (Windows, macOS, Linux).
3. Загрузите и запустите установщик, следуя инструкциям.

<img src="https://img001.prntscr.com/file/img001/4Fk7ldmKRXeXU03tWXbeeQ.png" width="600" alt="NodeJS download page" />

После установки проверьте корректность установки, открыв терминал и введя команды для проверки версий _Node.js_:

```bash
node -v  # Проверка версии Node.js
```

## Написание первого скрипта на Node.js

Попробуем написать простой код на Node.js. Создайте файл `index.js` со следующим содержимым:

```javascript
console.log("Hello, Node.js!");
```

Чтобы запустить это скрипт на компьютере, откройте терминал, перейдите в папку с файлом и выполните команду:

```bash
node index.js
```

Если всё сделано верно, в консоли вы увидите сообщение: *Hello from Node.js*. Таким образом, мы запустили JavaScript-приложение вне браузера – через Node.js. Это простой пример, но он демонстрирует основу: *Node.js позволяет выполнять ваш JavaScript на сервере или локальном компьютере напрямую, без браузера*.

## Основные особенности Node.js

Когда говорят о Node.js, часто упоминают его *событийно-ориентированную архитектуру* и неблокирующий ввод-вывод. Эти особенности отличают Node.js от традиционных серверных сред. Давайте разберем их по порядку.

### Событийно-ориентированная модель и однопоточное выполнение

Node.js построен на событийно-ориентированной (event-driven) архитектуре [^2]. Это значит, что вместо последовательного выполнения команд по шагам, Node.js работает в цикле, реагируя на происходящие события. Специальный механизм – *event loop (цикл событий)* – постоянно крутится в фоновом режиме и отслеживает события или задачи, которые должны выполниться. Например, когда приходит сетевой запрос или завершается операция чтения файла, соответствующее событие помещается в очередь, и когда Node.js готов, оно обрабатывается.

Важно отметить, что Node.js выполняет JavaScript-код в одном основном потоке. Это *однопоточная* (*single-threaded*) среда: все обработчики событий выполняются последовательно в рамках одного потока.

На первый взгляд кажется, что это ограничение – ведь одно ядро процессора выполняет задачи по очереди. Однако благодаря продуманной событийной модели Node.js умеет эффективно распределять время между множеством задач. Когда одна задача ожидает какого-то события (например, завершения запроса к базе данных), Node.js может переключиться и заняться обработкой других событий, не простаивая без дела.

## Неблокирующий ввод-вывод (non-blocking I/O)

Одной из ключевых особенностей Node.js является *неблокирующий ввод-вывод (non-blocking I/O)*.

*Блокирующий ввод-вывод* в традиционных средах означал, что если ваша программа читает файл с диска или делает запрос к базе данных, она приостанавливает выполнение (блокируется) до получения результата. В *асинхронной* же модели Node.js операции ввода-вывода выполняются в фоновом режиме, а основной поток не ждет их завершения. Вместо этого вы задаете колбек-функцию (или используете Promise/async-await), которая будет вызвана, когда операция завершится.

За счет этого *Node.js не простаивает впустую*: пока, скажем, читается файл с диска, Node может параллельно обрабатывать другие запросы или события. Такой механизм существенно повышает масштабируемость приложений – один сервер на Node.js способен обслуживать тысячи соединений одновременно, не создавая тысячи потоков.

## Работа с модулями и пакеты

Типичная Node.js-программа состоит из модулей. Node.js изначально реализовал систему модулей CommonJS, где для загрузки модуля используется функция `require()`. Любой файл в Node можно подключить как модуль, если он экспортирует нужные объекты через module.exports. Например, вы можете разделить логику приложения на файлы и подключать их друг к другу:

```javascript
// calc.js – модуль, экспортирующий функцию
function add(a, b) {
  return a + b;
}
module.exports = { add };
```

```javascript
// app.js – основной файл, использующий модуль calc.js
const calc = require('./calc.js');
console.log(calc.add(2, 3)); // Выведет 5
```

Такая модульность помогает структурировать код и повторно использовать функции. Помимо собственных модулей, Node.js имеет встроенные модули (core modules) – например:

- `fs`. Работа с файловой системой.
- `http`. Создание HTTP-сервера.
- `path`. Работа с путями файлов и директорий.

Эти модули можно подключать напрямую по имени, без установки, так как они идут изначально вместе с Node.js.

_Пример 1_. Использование встроенного модуля `fs` для чтения файла:

```javascript
const fs = require('fs');

fs.readFile('example.txt', 'utf8', (err, data) => {
  if (err) {
    console.error('Error reading file:', err);
    return;
  }
  console.log('File contents:', data);
});
```

## Менеджер пакетов npm

Один из важнейших инструментов в экосистеме Node.js – это менеджер пакетов `npm` (Node Package Manager).

### Что такое npm и зачем он нужен?

*npm (Node Package Manager)* — это встроенный менеджер пакетов для Node.js. Он позволяет разработчикам управлять сторонними библиотеками и зависимостями в проектах.

*Основные функции npm*:

- *Установка пакетов*. Добавление библиотек, необходимых для разработки.
- *Управление зависимостями*. Обновление или удаление установленных библиотек.
- *Автоматизация задач*. Запуск скриптов, указанных в файле `package.json`.

Простыми словами, с помощью этой утилиты можно управлять библиотеками в своем проекте через команды в терминале: добавлять новые, удалять ненужные или изменять их версии. Нет необходимости самостоятельно искать и загружать файлы вручную — npm выполнит всю работу за разработчика.

Пакеты доступные для установки через npm хранятся в онлайн-репозитории под названием *npm registry* (https://www.npmjs.com/). Это огромный каталог с тысячами библиотек на любой вкус: от утилит для работы с датами (например, `moment.js`) до полноценных фреймворков для создания серверов (например, `Express.js`).

### Основные команды npm

Вот несколько основных команд npm, которые часто используются в проектах на Node.js:

- `npm init` — инициализация нового проекта Node.js. Эта команда создаст файл `package.json`, в котором будут храниться метаданные проекта и его зависимости.
- `npm install <package-name>` — установка пакета из npm registry. Например, `npm install moment` установит библиотеку для работы с датами.
- `npm install` — установка всех зависимостей, указанных в файле `package.json` (рассмотрено ниже).
- `npm uninstall <package-name>` — удаление установленного пакета из проекта.
- `npm update <package-name>` — обновление установленного пакета до последней версии
- `npm list` — отображение всех установленных пакетов в проекте.
- и другие.

Полный список команд можно найти в официальной документации npm: https://docs.npmjs.com/cli/v11/commands.

### Хранение пакетов в проекте и файл package.json

Пакеты хранятся в специальной папке вашего проекта (по умолчанию `node_modules`). Эта папка создается автоматически при установке первого пакета через npm. Внутри `node_modules` находятся все установленные библиотеки и их зависимости.

Иногда данная директория может занимать много места на диске, так как каждая библиотека может иметь свои собственные зависимости. Поэтому обычно папку `node_modules` не включают в систему контроля версий (например, Git) — вместо этого в проекте хранится файл `package.json`, который описывает, какие пакеты нужны для работы приложения. Затем любой разработчик, взявший ваш проект, может просто выполнить `npm install` – и `npm` установит все перечисленные зависимости, указанные в `package.json`.

Например, структура `package.json` может выглядеть так:

```json
{
  "name": "my-node-app",
  "version": "1.0.0",
  "description": "A simple Node.js application",
  "main": "index.js",
  "scripts": {
    "start": "node index.js"
  },
  "dependencies": {
    "moment": "^2.29.1",
    "axios": "^0.21.1"
  }
}
```

При выполнении команды `npm install` будут установлены пакеты `moment` и `axios` в папку `node_modules`. Поэтому нет смысла хранить папку `node_modules` в репозитории, так как все необходимые зависимости можно легко восстановить из `package.json`.

### Semantic versioning (семантическое версионирование)

В `package.json` версии пакетов обычно записаны в формате `^1.2.3` или `~1.2.3`. npm следует *семантическому версионированию*, где:

- первая цифра – мажорная версия (несовместимые изменения), 
- вторая – минорная (новые возможности, совместимые изменения), 
- третья – патч (исправления багов).

Символы `^` и `~` задают правила обновления пакета при повторной установке.

- `^1.2.3` – позволяет обновляться до любой версии, которая не меняет мажорную версию (например, `1.3.0`, `1.4.5`, но не `2.0.0`).
- `~1.2.3` – позволяет обновляться только до патчей внутри минорной версии (например, `1.2.4`, `1.2.5`, но не `1.3.0`).

Также с помощью npm можно запускать скрипты вашего проекта (определяются в разделе "scripts" файла package.json).

В примере ниже определены два скрипта:

- `start`. Запускает файл `index.js` с помощью Node.js.
- `test`. Выводит сообщение об ошибке (обычно используется для запуска тестов).

_Пример 2_. Запуск скрипта из package.json:

```json
{
    "scripts": {
        "start": "node index.js",
        "test": "echo \"Error: no test specified\" && exit 1"
    }
}
```

## Создание проекта на Node.js с нуля

Теперь перейдем к практике и создадим простой проект на Node.js. Предположим, вы хотите начать разработку серверного приложения.

1. *Создание директории проекта*. Определитесь с именем вашего приложения и создайте новую директорию с соответствующим названием. Затем откройте эту папку в терминале/консоли.

    ```bash
    mkdir first-node-project
    cd first-node-project
    ```

2. *Инициализация проекта с помощью npm*. Выполните команду `npm init` для создания файла `package.json`. Эта команда задаст вам несколько вопросов о вашем проекте (название, версия, описание и т.д.). Вы можете нажимать Enter, чтобы принять значения по умолчанию, или ввести свои.

    ```bash
    npm init
    ```

    Если вы хотите сразу принять все настройки по умолчанию, можно выполнить `npm init -y` – тогда package.json создастся автоматически с базовыми полями без опроса.

3. *Создание основного файла приложения*.  По умолчанию точкой входа будет файл `index.js` (если вы не указали другое имя). 
   1. Создайте файл `index.js` в папке проекта. Добавьте туда какой-нибудь код на Node.js. Ниже приведен пример простейшего HTTP-сервера:

    ```js
    // index.js
    const http = require('http');

    const PORT = 3000;

    const server = http.createServer((req, res) => {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        res.end('My first Node.js server is running!\n');
    });

    server.listen(PORT, () => {
        console.log(`Server is listening on port ${PORT}`);
    });
    ```

    2. Запустите сервер командой `node index.js` в терминале. Если всё сделано правильно, вы увидите сообщение, что сервер запущен на порту 3000.
    3. Откройте браузер и перейдите по адресу `http://localhost:3000`. Вы должны увидеть сообщение от вашего сервера.
    4. Для остановки сервера нажмите `Ctrl + C` в терминале.

## Переменные окружения в Node.js

### Что такое переменные окружения и зачем они нужны?

При разработке серверных приложений очень важно иметь возможность настраивать приложение без изменения исходного кода – например, задавать разные настройки для локальной разработки и для продакшна. Для этого используются переменные окружения (*environment variables*).

*Переменные окружения* – это просто пары "ключ=значение", которые хранятся в операционной системе и доступны для всех процессов (программ), запущенных в этой операционной системе.

*Окружение* — это среда, в которой работает ваше приложение, например, разработка, тестирование или продакшен. В зависимости от окружения могут меняться такие параметры, как база данных, сервер, настройки безопасности, кэширование и другие.

Чаще, переменные окружения используется для хранения конфиденциальной информации, такой как пароли, ключи и другие параметры или настройки, могут меняться в зависимости от окружения (например, разработка, тестирование, продакшен). Это позволяет избежать размещения таких данных в коде и хранить их отдельно от репозитория.

Например, у вас есть переменные, для подключения к базе данных, они могут быть в разных окружениях разными, к тому же хранить пароли в коде – плохая практика. Вместо этого вы можете задать их как переменные окружения.


### Как задать и использовать переменные окружения в Node.js

Для того, чтобы использовать переменные окружения в Node.js, нужно обратиться к специальному объекту `process.env`. Этот объект содержит все переменные окружения, доступные для текущего процесса.

_Пример 3_. Использование переменных окружения в Node.js:

```javascript
// index.js
const http = require('http');
const PORT = process.env.PORT || 3000; // Используем переменную окружения PORT или значение по умолчанию 3000
const ENV = process.env.NODE_ENV || 'development'; // Переменная окружения NODE_ENV
const DB_PASSWORD = process.env.DB_PASSWORD; // Переменная окружения для пароля базы данных
```

Для того, чтобы определить переменную окружения, есть несколько способов [^3]:

- *В командной строке при запуске*.

    В Linux/Mac:

    ```bash
    NODE_ENV=production DB_PASSWORD=secret node index.js
    ```

    В Windows:

    ```bash
    set NODE_ENV=production && set DB_PASSWORD=secret && node index.js
    ```

- *Через системные настройки*. Можно установить переменные окружения в самой операционной системе (например, в Windows через свойства системы, в Linux в профиле shell). Тогда они будут доступны всем запущенным программам. Однако засорять глобальные настройки не всегда удобно, особенно если нужно задавать много переменных
- *Файл конфигурации (.env) и пакет dotenv*.  
  
    Очень распространенный и удобный способ – хранить переменные окружения в специальном файле, обычно называемом `.env`, в формате ИМЯ=значение (по одному на строку). Например:
  
    ```
    NODE_ENV=development
    DB_HOST=localhost
    DB_USER=root
    DB_PASSWORD=secret
    ```

    Этот файл не кладут в репозиторий, а держат локально (добавив `.env` в .gitignore, чтобы случайно не отправить секретные данные в открытый доступ). 

    Чтобы значения из файла `.env` подгрузились в `process.env` при запуске, используют пакет `dotenv`. Он идет как зависимость (установите `npm install dotenv`), после чего достаточно в самом начале приложения вызвать:

    ```javascript
    require('dotenv').config();
    ```

    Этот вызов прочитает файл `.env` (расположенный в корне проекта) и наполнит `process.env` соответствующими переменными.

Использование переменных окружения делает приложения гибкими. Вы можете иметь разные файлы `.env` для разработки и для продакшена (или задавать реальные переменные на сервере), и одно и то же приложение Node.js будет корректно подстраиваться под среду исполнения. Например, в разработке можно работать с тестовой базой данных, а на продакшене – с основной, просто задав разные URL в переменных окружения. Код приложения при этом остается единым.

[^1]: _About Node.js_. nodejs.org [online]. Available at: https://nodejs.org/en/about
[^2]: _Odin Project Node.js: A Comprehensive Guide_. w3tutorials.net [online]. Available at: https://www.w3tutorials.net/blog/odin-project-nodejs/
[^3]: _Environment Variables_. theodinproject.com [online]. Available at: https://www.theodinproject.com/lessons/nodejs-environment-variables