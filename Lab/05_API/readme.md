# Лабораторная работа №5. Работа с API

> Продолжите разработку приложения из предыдущей лабораторной работы (№4) или создайте новое приложение с нуля.

## Цель работы

1. Освоить один из альтернативных архитектурных стилей Web-API, отличных от REST (GraphQL, WebSockets, WebHooks, SOAP и др.).
2. Научиться выбирать архитектурный стиль под конкретную задачу и аргументировать свой выбор.
3. Расширить функциональность существующего сервиса, интегрируя новый тип API вместе с уже реализованным REST API.
4. Закрепить навыки проектирования и реализации backend-приложений на Node.js + Express в более «приближенном к продакшену» сценарии.

## Условие

### Шаг 1. Анализ архитектурных стилей API

1. Перечитайте конспект/лекцию по архитектурным стилям Web-API.
2. Кратко (для себя) ответьте:
   1. В чём ключевые особенности GraphQL?
   2. Когда оправдано использование WebSockets?
   3. Для каких задач удобны WebHooks?
   4. В каких сценариях до сих пор встречается SOAP?

Эти ответы пригодятся для дальнейшего выбора стиля API.

### Шаг 2. Выбор типа Web-API и обоснование

1. Проанализируйте текущую архитектуру вашего приложения, его существующую функциональность и возможные направления развития. На основе этого анализа выберите один тип Web-API, отличный от REST, который органично впишется в архитектуру вашего сервиса и позволит расширить его возможности. В качестве вариантов рассмотрите: GraphQL, WebSockets, WebHooks, SOAP (или другой подход, оправданный с точки зрения задачи).
2. Ваш выбор должен быть технически обоснован:
   1. какую проблему или ограничение текущего REST-подхода вы решаете;
   2. какие преимущества даёт выбранный архитектурный стиль именно вашему приложению;
   3. как он поможет улучшить производительность, взаимодействие клиентов или удобство разработки.

Результаты анализа и аргументацию выбора необходимо кратко описать в отчёте.

### Шаг 4. Проектирование новой функциональности

В зависимости от выбранного стиля API:

#### Вариант A: GraphQL

1. Спроектируйте GraphQL-схему, которая дополняет существующий REST API.
2. Минимальные требования:
   - Определите не менее 2 типов (`Type`).
   - Реализуйте не менее 2 запросов (`Query`) и 1 мутацию (`Mutation`).
   - Обеспечьте валидацию входных данных.

#### Вариант B: WebSockets

1. Спроектируйте real-time функциональность.
2. Минимальные требования:
   - Реализуйте серверную часть WebSocket с использованием `ws` или `socket.io`.
   - Обеспечьте обмен сообщениями между клиентами (например, чат или обновление данных в реальном времени).

#### Вариант C: WebHooks

1. Спроектируйте сценарий, при котором ваш сервис выступает как _отправитель WebHook_.
2. Минимальные требования:

   - Реализуйте возможность регистрации URL-ов для WebHook.
   - Реализуйте отправку HTTP-запросов на зарегистрированные URL при наступлении определённых событий (например, создание или обновление ресурса).

#### Вариант D: SOAP

1. Спроектируйте SOAP-сервис, который дополняет существующий REST API.
2. Минимальные требования:
   - Определите не менее 2 операций (методов).
   - Обеспечьте валидацию входных данных.

### Шаг 5. Реализация выбранного варианта

Ниже - примерные шаги, общие для всех вариантов (_конкретные библиотеки студент подбирает, опираясь на лекцию и документацию_).

1. Добавьте необходимые зависимости
2. Настройте новый endpoint или сервер:
   1. `/graphql` для GraphQL.
   2. WebSocket-сервер/namespace (например, через `socket.io`).
   3. `/webhooks/register` для регистрации WebHook URL-ов.
   4. `/soap` для SOAP.
3. Интегрируйте новый API со существующими моделями и логикой:
4. Учитывайте авторизацию (при необходимости — проверка JWT перед выполнением операций).
5. Убедитесь, что:
   1. REST API продолжает работать как раньше.
   2. Новый тип API действительно даёт дополнительную ценность, а не дублирует REST 1-в-1 просто ради галочки.

## Контрольные вопросы

1. В чём основные отличия REST от выбранного вами типа Web-API (GraphQL / WebSockets / WebHooks / SOAP)
2. В каких случаях использование вашего типа API даёт преимущество по сравнению с REST (по производительности, удобству, гибкости и т.д.)?
3. Какие ограничения или недостатки имеет выбранный вами архитектурный стиль?
4. Как вы интегрировали новый тип API с уже существующей архитектурой приложения (REST + БД + аутентификация)?
