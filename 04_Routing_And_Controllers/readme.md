# Маршрутизация в веб-приложениях. Контроллеры и Middleware

## Содержание

- [Маршрутизация в веб-приложениях. Контроллеры и Middleware](#маршрутизация-в-веб-приложениях-контроллеры-и-middleware)
  - [Содержание](#содержание)
  - [Маршрутизация в веб-приложениях](#маршрутизация-в-веб-приложениях)
    - [Введение в маршрутизацию](#введение-в-маршрутизацию)
    - [Зачем нужна маршрутизация?](#зачем-нужна-маршрутизация)
    - [Как работает маршрутизация?](#как-работает-маршрутизация)
  - [Маршрутизация в Express](#маршрутизация-в-express)
    - [Путь маршрута](#путь-маршрута)
    - [Маршрут 404](#маршрут-404)
    - [Объект запроса (req) и объект ответа (res)](#объект-запроса-req-и-объект-ответа-res)
  - [Контроллеры](#контроллеры)
    - [Что такое контроллер и зачем он нужен?](#что-такое-контроллер-и-зачем-он-нужен)
    - [Наименование и организация контроллеров](#наименование-и-организация-контроллеров)
  - [Группировка маршрутов с помощью Router](#группировка-маршрутов-с-помощью-router)
  - [Введение в middleware (промежуточные функции)](#введение-в-middleware-промежуточные-функции)
    - [Что такое middleware?](#что-такое-middleware)
    - [Цепочка middleware](#цепочка-middleware)
    - [Локальные и глобальные middleware](#локальные-и-глобальные-middleware)
  - [Структура директорий](#структура-директорий)
  - [Валидация параметров маршрута](#валидация-параметров-маршрута)

## Маршрутизация в веб-приложениях

### Введение в маршрутизацию

Прежде чем приступать к изучению маршрутизации в веб-приложениях, давайте разберёмся, что это такое и для чего она нужна. Что приходит вам на ум при слове «маршрут»? Вероятно, это связано с путешествиями, дорогами, маршрутами транспорта или направлениями следования. Например, существует троллейбусный маршрут №22, который следует из точки `A` в точку `B`. В целом, в веб-приложениях, маршрут, это тоже самое: путь от URL пользователя к определенному действию или контенту в приложении.

В веб-приложениях _маршрутизация_ означает определение путей, по которым пользователь может перемещаться внутри приложения. В зависимости от выбранного пользователем маршрута, приложение отображает соответствующий контент или выполняет определённые действия (_выполняет определённую функцию_) [^1].

Давайте рассмотрим пример для лучшего понимания. Представьте, что у вас есть веб-приложение, в котором есть две страницы: `Главная` и `О нас`. Пользователь может переходить между этими страницами, нажимая на соответствующие ссылки. В данном случае, `Главная` и `О нас` — это маршруты.

Как именно пользователь попадает на страницу `О нас`? Он переходит по маршруту, который определён для этой страницы. В данном случае, маршрут — это URL-адрес страницы `О нас`, например, `/about`.

### Зачем нужна маршрутизация?

Маршрутизация в веб-приложениях необходима для удобства пользователей. Благодаря маршрутизации пользователь может легко перемещаться по приложению, переходить между различными страницами и выполнять различные действия. Если бы в веб-приложениях не было маршрутизации, было бы сложнее найти нужную информацию или выполнить определённые действия. Например, он бы не мог скинуть ссылку на интересную статью другу или перейти на страницу с контактами.

### Как работает маршрутизация?

Механизмов маршрутизации в веб-приложениях существует множество, и они могут отличаться в зависимости от используемого фреймворка или библиотеки.

Однако, в целом, процесс маршрутизации можно описать следующим образом:

1. _Определение маршрутов в приложении_.
   1. Маршруты задаются с указанием URL-адресов и HTTP-методов (`GET`, `POST`, и т.д.), которые сопоставляются с определёнными функциями. Эти методы выполняют нужные действия и возвращают результат.
      1. `GET /` — главная страница (метод `index()`),
      2. `GET /about` — страница "О нас" (метод `about()`),
      3. `POST /product` — создание нового продукта (метод `createProduct()`),
      4. `GET /product/{id}` — страница товара по ID (метод `getProduct(int $id)`).
   2. _Переход пользователя по маршруту_.
      1. Пользователь вводит URL-адрес в браузере или кликает на ссылку, инициируя HTTP-запрос к серверу.
   3. _Поиск функции, связанного с маршрутом_.
      1. Приложение ищет маршрут, соответствующий указанному URL и HTTP-методу. Например, если запрос пришёл на `/about` с методом GET, приложение находит метод `about()`.
      2. Если подходящий маршрут не найден, приложение возвращает страницу с ошибкой 404.
   4. _Выполнение действия и отображение результата_.
      1. После того как маршрут найден, выполняется соответствующий метод (например, `about()`), который обрабатывает запрос, выполняет необходимые действия (например, получение данных из базы) и возвращает результат (например, HTML-страницу с информацией "О нас").
      2. Результат отображается пользователю в браузере.

> Этот алгоритм является общим и может варьироваться в зависимости от используемого фреймворка или библиотеки.

## Маршрутизация в Express

В общем, маршрутизация в Express работает аналогично другим фреймворкам: _URL-адрес и HTTP-метод_ запроса сопоставляются с определённой _функцией или методом_ в приложении.

Когда запрос от клиента поступает на сервер, Express проверяет определённые маршруты по порядку и ищет такой, у которого метод и путь совпадают с данным запросом. Если маршрут совпал, выполняется связанная с ним функция-обработчик (часто эта функция реализована как контроллер).

Express позволяет определять маршруты с помощью методов, соответствующих HTTP-методам. Вот основные из них:

```js
app.get(url, callback); // для GET-запросов
app.post(url, callback); // для POST-запросов
app.put(url, callback); // для PUT-запросов
app.patch(url, callback); // для PATCH-запросов
app.delete(url, callback); // для DELETE-запросов
app.all(url, callback); // для всех методов
```

Например, если необходимо обработать GET-запрос на главную страницу, можно использовать следующий код:

```js
const express = require('express');

const app = express();

app.get('/', (req, res) => {
  res.send('Hello, world!');
});

// Запуск сервера
app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

`app.get('/', ... )` задаёт маршрут, который будет реагировать на любой GET-запрос по пути `'/'` [^2]. Если бы мы вместо этого написали `app.post('/', ...)`, то обработчик вызывался бы только для POST-запросов к пути `/`.

### Путь маршрута

_Путь маршрута_ – это первый параметр при определении маршрута. Чаще всего указывается строка (либо шаблон, похожий на регулярное выражение). Например,

- `'/'` совпадает только с корнем сайта (главной страницей),
- `'/about'` – совпадает только с `'/about'`

Можно использовать и более сложные пути, используя _параметры маршрута_, они позволяют обрабатывать запросы с разными значениями внутри URL. В маршруте параметр обозначается двоеточием. Например, определим маршрут с параметром `:id`

```js
// Маршрут с параметром :id
app.get('/items/:id', (req, res) => {
  const itemId = req.params.id; // Express извлечёт значение вместо :id
  res.send(`Запрошен объект с ID = ${itemId}`);
});
```

В данном примере, маршрут `/items/:id` совпадёт с URL вида `/items/42`, `/items/abc` и т.д. – любое значение на месте `:id` будет воспринято как параметр.

Express автоматически помещает эти значения в объект `req.params` под ключами с именами параметров. В примере выше при запросе `GET /items/42`, `req.params` станет равен `{ id: "42" }`.

_Важен порядок определения маршрутов_. Express проверяет маршруты последовательно в том порядке, в котором они зарегистрированы в коде. Если два маршрута совпадают с одним и тем же URL, будет вызван обработчик первого из них. Например:

```js
app.get('/items/:id', (req, res) => {
  res.send(`Объект с ID = ${req.params.id}`);
});

app.get('/items/special', (req, res) => {
  res.send('Специальный объект');
});
```

В этом примере, запрос `GET /items/special` никогда не достигнет второго маршрута, потому что первый маршрут сработает первым и перехватит этот запрос, интерпретируя `special` как значение параметра `:id`. Чтобы избежать такой ситуации, нужно располагать более специфичные маршруты выше в коде:

```js
app.get('/items/special', (req, res) => {
  res.send('Специальный объект');
});

app.get('/items/:id', (req, res) => {
  res.send(`Объект с ID = ${req.params.id}`);
});
```

Кроме параметров маршрутов, Express позволяет получать и `query-параметры`, дополнительные данные в URL после знака `?`. Например, в URL `/search?term=nodejs&page=2`, `term` и `page` являются query-параметрами. Они доступны через объект `req.query`:

```js
app.get('/search', (req, res) => {
  const term = req.query.term; // значение параметра term
  const page = req.query.page; // значение параметра page
  res.send(`Поиск по термину: ${term}, страница: ${page}`);
});
```

Если параметры маршрута используются для идентификации ресурса (например, `/items/:id`), то query-параметры обычно применяются для _фильтрации_, _сортировки_ или _пагинации данных_ (например, `/items?sort=asc&page=2`).

### Маршрут 404

Если ни один из определённых маршрутов не совпадает с запросом, Express не сможет найти обработчик для этого запроса. В таком случае, обычно возвращается ответ с кодом состояния `404 Not Found`, что означает, что запрашиваемый ресурс не найден.

Чтобы обработать такие случаи, можно добавить маршрут 404 в конце всех определений маршрутов. Например:

```js
// Определение всех маршрутов выше...
// Маршрут 404 - должен быть последним
app.use((req, res) => {
  res.status(404).send('Страница не найдена');
});
```

Этот маршрут будет вызван, если ни один из предыдущих маршрутов не совпал с запросом. Здесь используется `app.use()`, чтобы перехватить все запросы, которые не были обработаны ранее, и вернуть ответ с кодом 404.

### Объект запроса (req) и объект ответа (res)

При обработке маршрутов в Express, функции-обработчики получают два основных объекта: `req` (request) и `res` (response). Данные объекты предоставляют информацию о запросе и методы для формирования ответа.

_req_ (объект запроса) содержит информацию о запросе, такую как:

- `req.params` — параметры маршрута (например, `:id` в `/items/:id`).
- `req.query` — query-параметры (например, `?term=nodejs&page=2`).
- `req.body` — тело запроса (используется в POST-запросах для передачи данных формы или JSON).
- `req.method` — HTTP-метод запроса (например, `GET`, `POST`).
- `req.url` — полный URL запроса.
- `req.headers` — заголовки запроса.
- `req.ip` — IP-адрес клиента.
- `req.path` — путь запроса без query-параметров.

_res_ (объект ответа) предоставляет методы для формирования и отправки ответа клиенту, такие как:

- `res.send()` — отправка простого текстового или HTML-ответа.
- `res.json()` — отправка JSON-ответа.
- `res.status()` — установка HTTP-кода состояния ответа (например, `200`, `404`).
- `res.redirect()` — перенаправление клиента на другой URL.
- `res.render()` — рендеринг шаблона (например, Pug или EJS) и отправка HTML-ответа.
- `res.set()` — установка заголовков ответа.
- `res.cookie()` — установка cookie в ответе.
- `res.end()` — завершение ответа без отправки данных.
- `res.download()` — отправка файла для скачивания клиентом.
- `res.type()` — установка типа содержимого ответа (например, `text/html`, `application/json`).

Примеры использования `req` и `res` в маршрутах:

```js
app.get('/items/:id', (req, res) => {
  const itemId = req.params.id; // Получение параметра маршрута
  // Логика для получения объекта по itemId...
  res.json({ id: itemId, name: 'Пример объекта' }); // Отправка JSON-ответа
});

app.post('/items', (req, res) => {
  const newItem = req.body; // Получение данных из тела запроса
  // Логика для создания нового объекта...
  res.status(201).json(newItem); // Отправка ответа с кодом 201 (создано)
});
```

## Контроллеры

Когда мы говорили, про архитектуру MVC, то упоминали, что контроллеры отвечают за обработку запросов и взаимодействие между моделью и представлением. В примерах выше, функции-обработчики маршрутов выполняли роль контроллеров, обрабатывая запросы и формируя ответы. Например, в следующем коде:

```js
app.get('about', (req, res) => {
  res.send('О нас');
});
```

Функция `(req, res) => { res.send('О нас'); }` является контроллером для маршрута `GET /about`. Она обрабатывает запрос и отправляет ответ клиенту.

### Что такое контроллер и зачем он нужен?

Когда маршрутов немного, логику обработки запроса можно описать прямо внутри стрелочной функции в `app.get`/`app.post`. Однако по мере роста приложения такой подход становится неудобным.

_Контроллер_ – это функция, которая отделяет собственно логику обработки запроса от кода маршрутизации. Иначе говоря, маршруты "направляют" запросы, а контроллеры их "обрабатывают". Контроллеры позволяют вынести обработчики в отдельные функции и модули, что делает код чище и организованнее [^3].

В контексте Express контроллер – это, по сути, та же функция-обработчик запроса function(req, res, next), просто вынесенная отдельно и переиспользуемая. Маршрут при этом становится кратким: он лишь указывает путь и привязывает к нему нужный контроллер. Рассмотрим простой пример без контроллеров и с ними. Допустим, у нас есть набор книг в виде массива. Без использования контроллера мы могли бы определить маршрут так:

```js
// Без контроллера: логика прямо в обработчике маршрута
app.get('/books', (req, res) => {
  const books = getAllBooksFromDatabase(); // псевдо-функция получения книг
  res.json(books);
});
```

Здесь внутри функции маршрута мы выполняем всю работу: получаем список книг (например, из базы данных или другого источника) и отправляем его клиенту. Такой подход работает, но если логики много, файл с маршрутами разрастается, его трудно поддерживать и тестировать. Вместо этого лучше вынести логику в отдельную функцию-контроллер. Например:

```js
// controllers/bookController.js
function listBooks(req, res) {
  const books = getAllBooksFromDatabase(); // получение данных (пока псевдокод)
  res.json(books);
}

export { listBooks };
```

Теперь мы можем подключить эту функцию при определении маршрута:

```js
import { listBooks } from './controllers/bookController.js';
// С контроллером: логика в отдельной функции
app.get('/books', listBooks);
```

При импорте функций можно объединять их в один объект, чтобы не писать много импортов:

```js
import * as bookController from './controllers/bookController.js';

app.get('/books', bookController.listBooks);
```

Маршрут `/books` по-прежнему обслуживает GET-запросы к списку книг, но вся бизнес-логика находится в `listBooks`. Это дает несколько преимуществ:

- _Повторное использование_. Контроллер (функцию) можно вызвать из разных мест, если потребуется, или протестировать отдельно.
- _Читаемость_. Файл маршрутов содержит только описание маршрутов (какой URL что вызывает), а детали реализации вынесены в контроллеры. Это проще читать и сопровождать.
- _Разделение ответственности_. Контроллеры отвечают за работу с данными и формирование ответа, а маршруты – только за сопоставление запроса с нужным контроллером.

> _Примечание_: В Express контроллеры не являются чем-то встроенным – это просто ваше соглашение организовывать код. Express-фреймворк сам по себе не навязывает структуру MVC, разработчик решает, как ему удобнее. Тем не менее, следование шаблону MVC – распространённая практика, упрощающая поддержку кода в крупном приложении [^4]. Функции контроллеров зачастую также называют действиями (actions), например `getAllBooks`, `createBook` и т.п., по типу выполняемой операции. Главное – держать их отдельными и понятными.

### Наименование и организация контроллеров

Контроллеры обычно организуются по функциональным областям приложения. Например, если у вас есть модели `User`, `Product` и `Order`, то логично создать отдельные контроллеры для каждой из этих моделей: `userController.js`, `productController.js`, `orderController.js`. Каждый контроллер будет содержать функции для обработки запросов, связанных с соответствующей моделью.

Методы контроллеров обычно именуются в соответствии с действиями, которые они выполняют. Например:

- `listUsers` – для получения списка всех пользователей.
- `getUser` – для получения данных конкретного пользователя по ID.
- `createUser` – для создания нового пользователя.
- `updateUser` – для обновления данных пользователя.
- `deleteUser` – для удаления пользователя.

Пример контроллера для маршрутов, связанных с управлением пользователями:

```js
// controllers/userController.js

export function listUsers(req, res) {
  // Логика для получения и отправки списка пользователей
  res.json(users);
}

export function getUser(req, res) {
  const userId = req.params.id;
  // Логика для получения и отправки данных пользователя по ID
  res.json(user);
}

// и т.д.
```

В данном случае контроллер - это просто набор функций, каждая из которых обрабатывает определённый тип запроса, связанный с пользователями. Иногда контроллеры организуют как классы.

```js
// controllers/userController.js
class UserController {
  listUsers(req, res) {
    // Логика для получения и отправки списка пользователей
    res.json(users);
  }

  getUser(req, res) {
    const userId = req.params.id;
    // Логика для получения и отправки данных пользователя по ID
    res.json(user);
  }
}

export default new UserController();
```

> Чаще в Express используют просто функции, так как классы не дают особых преимуществ в этом контексте.

## Группировка маршрутов с помощью Router

По мере добавления новых разделов сайта или компонентов API маршрутов может становиться очень много. Держать все определения маршрутов в одном файле (например, в `app.js`) быстро становится неудобно. Express решает эту проблему с помощью маршрутизаторов (Router).

_Маршрутизатор_ – это по сути "мини-приложение" или модуль маршрутов, который можно подвесить на определённый префикс URL. С помощью Router мы можем логически сгруппировать маршруты по какому-то признаку (например, по разделам сайта) и вынести их в отдельные файлы.

Представим, что мы разрабатываем библиотечный сайт и хотим иметь разделы для книг и авторов отдельно. У нас могут быть такие маршруты:

- Главная страница и прочие общие:
  - `GET /` - главная страница.
  - `GET /about` - страница "О нас".
  - `GET /contact` - страница контактов.
  - `POST /contact` – отправка сообщения через форму на странице контактов.
- Маршруты книг:
  - `GET /books` – список всех книг.
  - `GET /books/:id` – книга по ID.
  - `GET /books/:bookId/reserve` – зарезервировать книгу (форма).
- Маршруты авторов:
  - `GET /authors` – список всех авторов.
  - `GET /authors/:id` – страница конкретного автора.

Как можно заметить, список маршрутов уже достаточно большой. Чтобы код был организованно, создадим роутеры: например, `authorRouter` для всех маршрутов `/authors/..`. и `bookRouter` для маршрутов `/books/....` в отдельных файлах. В Express это делается так:

- Создаётся новый Router с помощью `express.Router()`.
- На этом роутере определяются маршруты так же, как на приложении (router.get, router.post и т.д.).
- Роутер экспортируется из модуля.
- В главном файле приложения роутер подключается через `app.use(<prefix>, router)`, где `<prefix>` - это общий префикс для всех маршрутов роутера. Например: `app.use('/books', bookRouter)`.

```js
// routes/authorRouter.js
import express from 'express';
const authorRouter = express.Router();

// Маршрут списка всех авторов
authorRouter.get('/', (req, res) => {
  res.send('Все авторы'); // для простоты отправляем текст
});

// Маршрут страницы конкретного автора по :authorId
authorRouter.get('/:authorId', (req, res) => {
  const authorId = req.params.authorId;
  res.send(`Страница автора с ID = ${authorId}`);
});

export default authorRouter;
```

```js
// routes/bookRouter.js
import express from 'express';
const bookRouter = express.Router();

// Маршрут списка всех книг
bookRouter.get('/', (req, res) => {
  res.send('Все книги'); // для простоты отправляем текст
});

// Маршрут страницы конкретной книги по :bookId
bookRouter.get('/:bookId', (req, res) => {
  const bookId = req.params.bookId;
  res.send(`Страница книги с ID = ${bookId}`);
});

export default bookRouter;
```

> Обратите внимание: в файле `authorRouter.js` мы определили маршруты `authorRouter.get('/')` и `authorRouter.get('/:authorId')` без `/authors` в начале пути. Это потому, что этот роутер будет применён на префиксе `/authors` при подключении к приложению. То есть пути роутера являются относительными к указанному префиксу.

В главном файле приложения (`app.js` или `server.js`) мы подключаем эти роутеры:

```js
// app.js

import express from 'express';
import authorRouter from './routes/authorRouter.js';
import bookRouter from './routes/bookRouter.js';

const app = express();

// Общие маршруты
app.use('/authors', authorRouter); // Все маршруты из authorRouter будут начинаться с /authors
app.use('/books', bookRouter); // Все маршруты из bookRouter будут начинаться с /books
```

Метод `app.use('/authors', authorRouter)` означает: "_Все запросы, начинающиеся с /authors, передавать в обработку authorRouter_". Например, запрос `GET /authors/5` сначала дойдёт до `app.use('/authors', ...)`, будет перенаправлен внутрь `authorRouter`, и там уже сопоставится с конкретным маршрутом `authorRouter.get('/:authorId')`.

Группируя маршруты подобным образом, мы добиваемся лучшей структуры: каждый файл отвечает за свою группу URL, код проще поддерживать.

## Введение в middleware (промежуточные функции)

### Что такое middleware?

Если с понятием маршруты и контроллеры вы возможно раньше сталкивались, то с понятием middleware скорее всего нет. В веб-разработке, _middleware_ (промежуточное ПО) - это функции, которые вызываются во время обработки HTTP-запроса, но до того, как запрос достигнет конечного обработчика (контроллера). Middleware функции могут изменять объект запроса (`req`), объект ответа (`res`), завершать цикл запрос-ответ или передавать управление следующей функции middleware в стеке.

Простыми словами, middleware - это функции, которые "промежуточно" обрабатывают запросы и ответы на пути от клиента к серверу и обратно. Они могут выполнять различные задачи, такие как:

- Логирование запросов (например, запись информации о каждом запросе в консоль или файл).
- Аутентификация и авторизация (проверка, имеет ли пользователь право доступа к определённому ресурсу).
- Парсинг тела запроса (например, преобразование JSON или данных формы в объект JavaScript).
- Обработка ошибок (перехват и обработка ошибок, возникающих в процессе обработки запроса).
- Добавление заголовков к ответу (например, установка CORS-заголовков).

То есть, если у нас есть логика, которая должна выполняться для многих маршрутов (например, проверка авторизации), то очень не логично, чтобы эту логику дублировать в каждом контроллере. Вместо этого, мы можем создать middleware, который будет выполняться перед контроллером и проверять авторизацию.

Для создания middleware в Express используется функция с тремя параметрами: `req`, `res` и `next`. Вот пример простого middleware, который логирует каждый запрос:

```js
// middleware/logRequests.js

function logRequests(req, res, next) {
  console.log(`${req.method} ${req.url}`);
  // Передаём управление следующему middleware или маршруту
  // Если не вызвать next(), запрос "зависнет" здесь
  next();
}
```

Чтобы использовать middleware в приложении Express, его нужно "подключить" с помощью `app.use()` или непосредственно к определённому маршруту. Например:

```js
// app.js

import express from 'express';
const app = express();

// Подключаем глобальный middleware для логирования всех запросов
app.use(logRequests);

// Маршрут для главной страницы
app.get('/', (req, res) => {
  res.send('Hello, world!');
});

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```

В этом примере, каждый раз, когда приходит запрос к серверу, сначала выполняется middleware `logRequests`, который выводит в консоль метод и URL запроса, а затем вызывает `next()`, чтобы передать управление следующему обработчику (в данном случае маршруту `/`).

### Цепочка middleware

Middleware функции могут быть связаны в цепочку, где каждая функция выполняется последовательно. Это позволяет создавать сложные процессы обработки запросов, разбивая их на отдельные шаги. Например, можно создать цепочку middleware для аутентификации и логирования:

```js
// middleware/authenticate.js

function authenticate(req, res, next) {
  // Логика аутентификации пользователя
  const isAuthenticated = true; // Псевдо-проверка
  if (isAuthenticated) {
    next(); // Пользователь аутентифицирован, передаём управление дальше
  } else {
    // Если не аутентифицирован, отправляем ответ с ошибкой и прерываем цепочку
    res.status(401).send('Unauthorized');
  }
}

app.use(logRequests); // Логирование всех запросов

app.use(authenticate); // Аутентификация всех запросов

app.get('/protected', (req, res) => {
  res.send('This is a protected route');
});
```

В этом примере, при запросе к маршруту `/protected`, сначала выполняется `logRequests`, затем `authenticate`. Если пользователь аутентифицирован, управление передаётся в маршрут `/protected`, иначе возвращается ошибка 401.

> Официальная документация гласит: _Express-приложение по сути является цепочкой вызовов middleware-функций_. Иными словами, каждый запрос, проходя через Express, последовательно обрабатывается рядом функций-мидлваров.

### Локальные и глобальные middleware

Выше мы видели пример глобального middleware, подключённого через `app.use()`, который выполняется для всех запросов. Однако, иногда нужно, чтобы middleware выполнялся только для определённых маршрутов. В этом случае можно подключить middleware непосредственно к маршруту:

```js
app.get('/special', logRequests, (req, res) => {
  res.send('This is a special route');
});
```

В этом примере, middleware `logRequests` будет выполняться только для маршрута `/special`, а не для всех запросов.

Если нужно подключить несколько middleware к одному маршруту, их можно перечислить в массиве:

```js
app.get('/complex', [logRequests, authenticate], (req, res) => {
  res.send('This is a complex route with multiple middleware');
});
```

В случае необходимости, middleware можно также подключать к роутерам (Router), чтобы они применялись ко всем маршрутам внутри этого роутера:

```js
// routes/bookRouter.js

import express from 'express';
const bookRouter = express.Router();

// Подключаем middleware ко всем маршрутам bookRouter
bookRouter.use(authenticate);

bookRouter.get('/', (req, res) => {
  res.send('All books');
});
```

В этом примере, middleware `authenticate` будет выполняться для всех маршрутов внутри `bookRouter`.

## Структура директорий

При использовании нескольких файлов роутеров и контроллеров стоит организовать проект в понятную структуру. Сам Express не навязывает конкретной структуры, но есть общепринятые практики.

Обычно проект организуют следующим образом:

- `routes/` – для файлов с роутерами (например, `authorRouter.js`, `bookRouter.js`).
- `controllers/` – для файлов с контроллерами (например, `authorController.js`, `bookController.js`).
- `middleware/` – для файлов с middleware (например, `logRequests.js`, `authenticate.js`).

```
project-folder/
├── app.js                # Главный файл приложения (запуск сервера, подключение роутеров)
├── controllers/          # Контроллеры (логика обработки запросов)
│   ├── bookController.js
│   └── authorController.js
├── routes/               # Маршруты (привязка URL к контроллерам)
│   ├── bookRouter.js
│   └── authorRouter.js
├── middleware/           # Middleware (промежуточные функции)
│   ├── logRequests.js
│   └── authenticate.js
└── package.json
```

Такой подход соответствует MVC-паттерну: маршруты и контроллеры составляют контроллерный уровень, модели (если бы были) инкапсулируют работу с данными, а views – представление (HTML).

> С расширением проекта, можно добавлять и другие папки, например, `models/` для моделей данных, `views/` для шаблоно. Главное – придерживаться логической структуры, чтобы было легко ориентироваться в коде.

## Валидация параметров маршрута

_Валидация параметров маршрута_ – это процесс проверки и подтверждения того, что параметры, передаваемые в URL, соответствуют ожидаемым форматам и требованиям. Это важно для обеспечения безопасности и корректной работы приложения.

В Express нет встроенных средств для валидации параметров маршрута, но можно использовать сторонние библиотеки, такие как `Joi`, `express-validator` или `yup`. Эти библиотеки позволяют определять схемы валидации и проверять параметры перед их использованием в контроллерах.

Ниже приведен пример, как можно использовать `express-validator` для валидации параметров маршрута:

```js
import express from 'express';
import { param, validationResult } from 'express-validator';
const app = express();
// Маршрут с валидацией параметра :id
app.get(
  '/items/:id',
  // Валидация параметра :id (должен быть числом)
  param('id').isInt().withMessage('ID должен быть целым числом'),
  (req, res) => {
    // Проверка результатов валидации
    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const itemId = req.params.id;

    res.send(`Запрошен объект с ID = ${itemId}`);
  },
);
```

Если валидация не пройдена, то клиент получит ответ с кодом `400 Bad Request` и сообщением об ошибке в формате JSON:

```json
{
  "errors": [
    {
      "msg": "ID должен быть целым числом",
      "param": "id",
      "location": "params"
    }
  ]
}
```

Валидацию параметров можно отделять в отдельные middleware-функции, чтобы не загромождать контроллеры. Например:

```js
// validators/idValidator.js
import { param } from 'express-validator';

export const idValidator = [param('id').isInt().withMessage('ID должен быть целым числом')];
```

```js
// middleware/validate.js
import { validationResult } from 'express-validator';

export function validate(req, res, next) {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      errors: errors.array().map((err) => ({
        field: err.param,
        message: err.msg,
      })),
    });
  }
  next();
}
```

```js
// app.js
import express from 'express';
import { idValidator } from './validators/idValidator.js';
import { validate } from './middleware/validate.js';

const app = express();
app.get('/items/:id', idValidator, validate, (req, res) => {
  const itemId = req.params.id;
  res.send(`Запрошен объект с ID = ${itemId}`);
});
```

В данном примере, `idValidator` определяет правила валидации для параметра `:id`, а middleware `validate` проверяет результаты валидации и отправляет ошибку, если что-то не так. Если всё в порядке, управление передаётся дальше к контроллеру.

[^1]: _What Is a Router in Web Development?_. oyova.com [online]. Available at: https://www.oyova.com/blog/what-is-a-route-web-dev/
[^2]: _Routes_. theodinproject [online]. Available at: https://www.theodinproject.com/lessons/nodejs-routes
[^3]: _Express Tutorial Part 4: Routes and controllers_. developer.mozilla.org [online]. Available at: https://developer.mozilla.org/en-US/docs/Learn_web_development/Extensions/Server-side/Express_Nodejs/routes
[^4]: _Controllers_. theodinproject [online]. Available at: https://www.theodinproject.com/lessons/nodejs-controllers
